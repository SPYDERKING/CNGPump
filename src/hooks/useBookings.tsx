import { useState, useEffect } from 'react';

import { useAuth } from './useAuth';
import * as QRCode from 'qrcode';
import { API_CONFIG } from '@/lib/apiConfig';

export interface Booking {
  id: string;
  user_id: string;
  pump_id: string;
  slot_date: string;
  slot_time: string;
  fuel_quantity: number;
  amount: number;
  payment_status: string;
  booking_status: string;
  confirmation_status: string | null;
  created_at: string;
  updated_at: string;
  pump?: {
    name: string;
    address: string;
    city: string;
  };
  token?: Token;
}

export interface Token {
  id: string;
  booking_id: string;
  token_code: string;
  qr_data: string;
  expiry_time: string;
  scan_time: string | null;
  status: string;
  created_at: string;
}

export interface CreateBookingInput {
  pump_id: string;
  slot_date: string;
  slot_time: string;
  fuel_quantity: number;
  amount: number;
}

export const useBookings = () => {
  const { user, session } = useAuth();
  const [bookings, setBookings] = useState<Booking[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchBookings = async () => {
    if (!user || !session) {
      setBookings([]);
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      
      // Fetch bookings from our backend API
      const response = await fetch(`${API_CONFIG.ENDPOINTS.BOOKINGS.BASE}?user_id=${user.id}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      // For now, we'll just set the bookings as-is
      // In a real implementation, we'd need to fetch pump details and tokens separately
      setBookings(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch bookings');
    } finally {
      setLoading(false);
    }
  };

  const createBooking = async (input: CreateBookingInput) => {
    if (!user || !session) {
      return { error: new Error('User not authenticated'), data: null };
    }

    try {
      // Create booking through our backend API
      // The backend will automatically generate the e-token
      const response = await fetch(API_CONFIG.ENDPOINTS.BOOKINGS.BASE, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          user_id: user.id,
          pump_id: input.pump_id,
          slot_date: input.slot_date,
          slot_time: input.slot_time,
          fuel_quantity: input.fuel_quantity,
          amount: input.amount,
          payment_status: 'pending',
          booking_status: 'confirmed'
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const booking = await response.json();
      
      // Fetch the token that was automatically generated by the backend
      const tokenResponse = await fetch(`${API_CONFIG.ENDPOINTS.TOKENS.BASE}/booking/${booking.id}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json',
        }
      });

      if (!tokenResponse.ok) {
        throw new Error(`HTTP error fetching token! status: ${tokenResponse.status}`);
      }

      const token = await tokenResponse.json();

      // Refresh bookings
      await fetchBookings();

      return { error: null, data: { booking, token } };
    } catch (err) {
      return { error: err as Error, data: null };
    }
  };

  const updateConfirmationStatus = async (bookingId: string, status: 'coming' | 'not_coming') => {
    if (!session) {
      return { error: new Error('User not authenticated') };
    }
    
    try {
      // Update booking through our backend API
      const response = await fetch(`${API_CONFIG.ENDPOINTS.BOOKINGS.BASE}/${bookingId}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          confirmation_status: status,
          booking_status: status === 'not_coming' ? 'cancelled' : 'confirmed'
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      // If cancelled, expire the token
      if (status === 'not_coming') {
        const tokenResponse = await fetch(`${API_CONFIG.ENDPOINTS.TOKENS.BASE}/expire/${bookingId}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${session.access_token}`,
            'Content-Type': 'application/json',
          }
        });

        if (!tokenResponse.ok) {
          throw new Error(`HTTP error expiring token! status: ${tokenResponse.status}`);
        }
      }

      await fetchBookings();
      return { error: null };
    } catch (err) {
      return { error: err as Error };
    }
  };

  const cancelBooking = async (bookingId: string) => {
    if (!session) {
      return { error: new Error('User not authenticated') };
    }
    
    try {
      // Cancel booking through our backend API
      const response = await fetch(`${API_CONFIG.ENDPOINTS.BOOKINGS.BASE}/${bookingId}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          booking_status: 'cancelled',
          confirmation_status: 'not_coming'
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      // Expire the token
      const tokenResponse = await fetch(`${API_CONFIG.ENDPOINTS.TOKENS.BASE}/expire/${bookingId}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json',
        }
      });

      if (!tokenResponse.ok) {
        throw new Error(`HTTP error expiring token! status: ${tokenResponse.status}`);
      }

      await fetchBookings();
      return { error: null };
    } catch (err) {
      return { error: err as Error };
    }
  };

  useEffect(() => {
    fetchBookings();
  }, [user]);

  return { 
    bookings, 
    loading, 
    error, 
    refetch: fetchBookings,
    createBooking,
    updateConfirmationStatus,
    cancelBooking
  };
};

function generateTokenCode(): string {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let result = 'CNG-';
  for (let i = 0; i < 6; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}
